<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不穿辣条吃秋裤</title>
  
  <subtitle>LeonHuang Blogs</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongtao-huang.github.io/"/>
  <updated>2019-05-05T08:23:05.448Z</updated>
  <id>https://hongtao-huang.github.io/</id>
  
  <author>
    <name>黄洪涛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数防抖（debounce）与函数节流（throttle）</title>
    <link href="https://hongtao-huang.github.io/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
    <id>https://hongtao-huang.github.io/函数防抖与函数节流/</id>
    <published>2019-05-05T15:00:00.000Z</published>
    <updated>2019-05-05T08:23:05.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数防抖（debounce）与函数节流（throttle）"><a href="#函数防抖（debounce）与函数节流（throttle）" class="headerlink" title="函数防抖（debounce）与函数节流（throttle）"></a>函数防抖（debounce）与函数节流（throttle）</h1><h2 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h2><ul><li>函数防抖就像某些打怪升级游戏中的法师施放某个技能需要读条，或者说需要蓄力（施放这个法术需要几秒），当技能条没有读满就松开了按键再次重新按下时就要重新读条。以下代码实现了一个简单的防抖函数功能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let timerId;</span><br><span class="line">function debounce(fn, delay)&#123;</span><br><span class="line">  clearTimeout(timerId);</span><br><span class="line">  timerId = setTimeout(fn, delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const inputa = document.getElementById(&apos;inputa&apos;);</span><br><span class="line">inputa.addEventListener(&apos;keyup&apos;, (e) =&gt; &#123;</span><br><span class="line">  debounce((value = e.target.value) =&gt; console.log(value), 2000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><ul><li>函数节流就像王者荣耀的某个英雄施放技能， 一个技能施放之后会有冷却时间。 所以函数节流就是规定间隔一段时间执行，在间隔时间内只执行一次。以下代码实现了一个简单的函数节流函数功能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let timerIdTh;</span><br><span class="line">function throttle(fn, delay)&#123;</span><br><span class="line">  if(timerIdTh)&#123;</span><br><span class="line">    console.log(&apos;技能冷却中。。。&apos;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  timerIdTh = setTimeout(() =&gt; &#123;</span><br><span class="line">    clearTimeout(timerIdTh);</span><br><span class="line">    timerIdTh = &apos;&apos;;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const buttona = document.getElementById(&apos;buttona&apos;);</span><br><span class="line">buttona.addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">  throttle(() =&gt; console.log(&apos;哦里呀给&apos;), 2000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数防抖（debounce）与函数节流（throttle）&quot;&gt;&lt;a href=&quot;#函数防抖（debounce）与函数节流（throttle）&quot; class=&quot;headerlink&quot; title=&quot;函数防抖（debounce）与函数节流（throttle）&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="函数防抖, debounce, 函数节流, throttle" scheme="https://hongtao-huang.github.io/tags/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96-debounce-%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81-throttle/"/>
    
  </entry>
  
  <entry>
    <title>create-react-app 路由按需加载</title>
    <link href="https://hongtao-huang.github.io/react-create-react-app%20%E8%B7%AF%E7%94%B1%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/"/>
    <id>https://hongtao-huang.github.io/react-create-react-app 路由按需加载/</id>
    <published>2019-04-15T15:00:00.000Z</published>
    <updated>2019-04-15T07:42:50.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="create-react-app-路由按需加载"><a href="#create-react-app-路由按需加载" class="headerlink" title="create-react-app 路由按需加载"></a>create-react-app 路由按需加载</h1><p>由<code>create-react-app</code>创建的react应用是将webpack的配置项隐藏的，可以让开发者在不需要做任何配置的情况下开发react，但有时候开发者也会需要有些特殊的需求</p><ol><li><code>npm run eject</code>将webpack抛出再自己添加配置以解决需求</li><li>通过<code>react-app-rewired</code>以及<code>customize-cra</code>来解决特殊需求</li><li>正常的antd 按需加载 以及<code>less</code> <code>sass</code> <code>alias</code>等配置在网上都有大佬写出教程。  </li><li>作为一个react 小白， 我就是很作。<br>我就是想在不抛出webpack配置的情况下来做到路由组件的按需加载，经过在网络的漫长搜索， 发现都是通过抛出webpack 的方式来做按需加载。</li></ol><p>通过一番努力， 发现抛出方式都是在<code>.babelrc</code>的<code>plugins</code>上添加一个<code>syntax-dynamic-import</code>插件。 于是借此解决了在不抛出配置的情况下按需加载问题。解决如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const &#123;override, addBabelPlugins, useBabelRc&#125; = require(&apos;customize-cra&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = override(</span><br><span class="line">    addBabelPlugins(</span><br><span class="line">        [&quot;syntax-dynamic-import&quot;,&#123;&quot;legacy&quot;: true&#125;],</span><br><span class="line">    ),useBabelRc());</span><br></pre></td></tr></table></figure></p><p>在组件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import Loadable from &apos;react-loadable&apos;;</span><br><span class="line"></span><br><span class="line">const MyLoadingComponent = (&#123;isLoading, error&#125;) =&gt; &#123;</span><br><span class="line">  // Handle the loading state</span><br><span class="line">  if (isLoading) &#123;</span><br><span class="line">    return &lt;div&gt;没有&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  // Handle the error state</span><br><span class="line">  else if (error) &#123;</span><br><span class="line">    return &lt;div&gt;Sorry, there was a problem loading the page.&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const LoadableComponent = Loadable(&#123;</span><br><span class="line">                  loader: () =&gt; import(&apos;/pages/index&apos;),</span><br><span class="line">                  loading: MyLoadingComponent</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure></p><p>至此按需加载算是完成了</p><ul><li>后来发现react更新后添加了两个新特性<code>Suspense, lazy</code>可以直接通过引入这两个特性做到按需加载， 根本不需要上面那么麻烦的配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component, Suspense, lazy&#125; from &apos;react&apos;;</span><br><span class="line">const DynamicComponent = lazy (() =&gt; import(&apos;/pages/index&apos;));</span><br><span class="line"> &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line"> &lt;DynamicComponent /&gt;</span><br><span class="line"> &lt;/Suspense&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;create-react-app-路由按需加载&quot;&gt;&lt;a href=&quot;#create-react-app-路由按需加载&quot; class=&quot;headerlink&quot; title=&quot;create-react-app 路由按需加载&quot;&gt;&lt;/a&gt;create-react-app 
      
    
    </summary>
    
      <category term="react" scheme="https://hongtao-huang.github.io/categories/react/"/>
    
    
      <category term="create-react-app,customize-cra,react-app-rewired" scheme="https://hongtao-huang.github.io/tags/create-react-app-customize-cra-react-app-rewired/"/>
    
  </entry>
  
  <entry>
    <title>react-router4.0 路由登录拦截</title>
    <link href="https://hongtao-huang.github.io/react-router%204.0%20%E8%B7%AF%E7%94%B1%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA/"/>
    <id>https://hongtao-huang.github.io/react-router 4.0 路由登录拦截/</id>
    <published>2019-04-15T15:00:00.000Z</published>
    <updated>2019-04-15T03:36:58.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-router4-0-路由登录拦截"><a href="#react-router4-0-路由登录拦截" class="headerlink" title="react-router4.0 路由登录拦截"></a>react-router4.0 路由登录拦截</h1><h2 id="创建路由表"><a href="#创建路由表" class="headerlink" title="创建路由表"></a>创建路由表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const routers = [</span><br><span class="line">  &#123;path: &quot;/&quot;, name: &quot;Index&quot;, component: &apos;./pages/Index&apos;&#125;,</span><br><span class="line">  &#123;path: &quot;/login&quot;, name: &quot;Login&quot;, component: &apos;./pages/Login&apos;&#125;,</span><br><span class="line">  &#123;path: &quot;/register&quot;, name: &quot;Register&quot;, component: &apos;./pages/Register&apos;&#125;,</span><br><span class="line">  &#123;path: &quot;/my&quot;, name: &quot;My&quot;, component: &apos;./pages/My&apos;, auth: true&#125;,</span><br><span class="line">  &#123;path: &quot;/create&quot;, name: &quot;Create&quot;, component: &apos;./pages/Create&apos;, auth: true&#125;,</span><br><span class="line">  &#123;path: &quot;/detail/:blogId&quot;, name: &quot;Detail&quot;, component: &apos;./pages/Detail&apos;, auth: true&#125;,</span><br><span class="line">  &#123;path: &quot;/edit/:blogId&quot;, name: &quot;Edit&quot;, component: &apos;./pages/Edit&apos;, auth: true&#125;,</span><br><span class="line">  &#123;path: &quot;/user/:userId&quot;, name: &quot;User&quot;, component: &apos;./pages/User&apos;, auth: true&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="遍历路由表"><a href="#遍历路由表" class="headerlink" title="遍历路由表"></a>遍历路由表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component, Suspense, lazy&#125; from &apos;react&apos;;</span><br><span class="line">import &#123;BrowserRouter as Router, Route, Switch, Redirect&#125; from &apos;react-router-dom&apos;</span><br><span class="line">import routers from &apos;./router&apos;</span><br><span class="line">import &#123;NotFound&#125; from &apos;pages&apos;</span><br><span class="line">import &#123;Page&#125; from &apos;components&apos;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  async componentWillMount() &#123;</span><br><span class="line">    await this.props.dispatch(authActions.getAuthInfo());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &#123;</span><br><span class="line">              routers.map((item, index) =&gt; &#123;</span><br><span class="line">                const DynamicComponent = lazy (() =&gt; import(`$&#123;item.component&#125;/index`)); </span><br><span class="line">                return &lt;Route key=&#123;index&#125; path=&#123;item.path&#125; exact render=&#123;props =&gt; (</span><br><span class="line">                    &lt;Page &#123;...props&#125;&gt;</span><br><span class="line">                      &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">                      &#123;</span><br><span class="line">                        !item.auth</span><br><span class="line">                            ? (&lt;DynamicComponent &#123;...props&#125; /&gt;)</span><br><span class="line">                            : (token</span><br><span class="line">                                ? (&lt;DynamicComponent &#123;...props&#125; /&gt;)</span><br><span class="line">                                : (&lt;Redirect to=&#123;&#123; pathname: &quot;/login&quot;, state: &#123;from: props.location&#125;</span><br><span class="line">                                &#125;&#125;/&gt;)</span><br><span class="line">                            )</span><br><span class="line">                      &#125;</span><br><span class="line">                      &lt;/Suspense&gt;</span><br><span class="line">                    &lt;/Page&gt;</span><br><span class="line">                )&#125;&gt;</span><br><span class="line">                &lt;/Route&gt;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            &lt;Route component=&#123;NotFound&#125;/&gt;</span><br><span class="line">          &lt;/Switch&gt;</span><br><span class="line">        &lt;/Router&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><ul><li>关于BrowserRouter Switch Route 等可直接查看<a href="https://react-router.docschina.org/" target="_blank" rel="noopener">官方文档</a></li><li>该教程用到了Suspense, lazy来做页面的懒加载，这是react 的新特性， 所以不需要再引入外部的插件来做懒加载， 会在我的另一篇博客中讲到</li><li>在遍历路由表的情况下， 会先将layout 组件 <code>Page</code> 放在最外层， 也就是只要不是404页面， layout布局都会渲染，然后再判断 <code>auth</code> ，这个字段是来判断当匹配到这个路由的时候你是否需要做拦截，然后再判断是否有token</li><li>token的保存存储以及获取则是另外的解决方案</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;react-router4-0-路由登录拦截&quot;&gt;&lt;a href=&quot;#react-router4-0-路由登录拦截&quot; class=&quot;headerlink&quot; title=&quot;react-router4.0 路由登录拦截&quot;&gt;&lt;/a&gt;react-router4.0 路由登录
      
    
    </summary>
    
      <category term="react" scheme="https://hongtao-huang.github.io/categories/react/"/>
    
    
      <category term="react-router" scheme="https://hongtao-huang.github.io/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>react-router4.0 路由传参跳转及获取参数</title>
    <link href="https://hongtao-huang.github.io/react-router%204.0%20%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E8%B7%B3%E8%BD%AC%E5%8F%8A%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0/"/>
    <id>https://hongtao-huang.github.io/react-router 4.0 路由传参跳转及获取参数/</id>
    <published>2019-04-15T15:00:00.000Z</published>
    <updated>2019-04-15T07:04:52.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-router4-0-路由传参跳转及获取参数"><a href="#react-router4-0-路由传参跳转及获取参数" class="headerlink" title="react-router4.0 路由传参跳转及获取参数"></a>react-router4.0 路由传参跳转及获取参数</h1><p>路由的跳转，传参分别是通过路由的三个属性<code>history</code>,<code>location</code>,<code>match</code>来进行的,可通过从最上层的路由props传至组件中，也可以通过以下形式获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;withRouter&#125; from &apos;react-router-dom&apos;</span><br><span class="line">export default withRouter(Index)</span><br></pre></td></tr></table></figure></p><p>这样<code>Index</code>组件的props就可以拿到这三个属性了</p><h2 id="传参跳转history"><a href="#传参跳转history" class="headerlink" title="传参跳转history"></a>传参跳转<code>history</code></h2><h3 id="params"><a href="#params" class="headerlink" title="params"></a>params</h3><ol><li>需要现在路由表中配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/:id&quot;&gt;</span><br><span class="line">```</span><br><span class="line">2. 通过`history.push`进行跳转</span><br></pre></td></tr></table></figure></li></ol><p>history.push(‘/123’);  //或者<br>history.push({pathname: ‘/123’});</p><p><link path="/123"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3. history 属性中还有一些其他的方法，此处不提。其他文档中都可以查到</span><br><span class="line"></span><br><span class="line">### query</span><br><span class="line">1. 通过`history.push`进行跳转</span><br></pre></td></tr></table></figure></p><p>history.push({pathname: ‘/‘, search=”?page=1”});</p><p><link path="/?page=123"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 获取参数 </span><br><span class="line">### params `match`</span><br><span class="line">- params 获取参数是通过`match` 获取参数</span><br><span class="line">- `match.params.xxx`</span><br><span class="line"></span><br><span class="line">### query `location`</span><br><span class="line">- query 获取参数是通过`location`获取参数</span><br><span class="line">- `location.search`获取到`?page=1`字符串</span><br><span class="line">- `yarn add query-string`</span><br><span class="line">- `queryString.parse(location.search);`</span><br><span class="line">- 就可以将参数转换成对象</span><br><span class="line"></span><br><span class="line">还有种跳转是 state</span><br><span class="line">1. 通过`history.push`进行跳转</span><br></pre></td></tr></table></figure></p><p>history.push({pathname: ‘/‘, state={page:1}});<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;react-router4-0-路由传参跳转及获取参数&quot;&gt;&lt;a href=&quot;#react-router4-0-路由传参跳转及获取参数&quot; class=&quot;headerlink&quot; title=&quot;react-router4.0 路由传参跳转及获取参数&quot;&gt;&lt;/a&gt;react
      
    
    </summary>
    
      <category term="react" scheme="https://hongtao-huang.github.io/categories/react/"/>
    
    
      <category term="react-router" scheme="https://hongtao-huang.github.io/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>深入理解jQuery</title>
    <link href="https://hongtao-huang.github.io/%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0jQuery%E6%96%B9%E6%B3%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jQuery/"/>
    <id>https://hongtao-huang.github.io/自我实现jQuery方法深入理解jQuery/</id>
    <published>2018-06-30T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解jQuery"><a href="#深入理解jQuery" class="headerlink" title="深入理解jQuery"></a>深入理解jQuery</h1><h2 id="自我封装jQuery代码"><a href="#自我封装jQuery代码" class="headerlink" title="自我封装jQuery代码"></a>自我封装jQuery代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = function(nodeOrSelector) &#123;</span><br><span class="line">  let nodes = &#123;&#125;</span><br><span class="line">  if (typeof nodeOrSelector === &apos;string&apos;) &#123;</span><br><span class="line">    let tmp = document.querySelectorAll(nodeOrSelector);</span><br><span class="line">    for(var i =0; i &lt; tmp.length; i++)&#123;</span><br><span class="line">      nodes[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.length = i;</span><br><span class="line">  &#125; else if (nodeOrSelector instanceof Node) &#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      0: nodeOrSelector,</span><br><span class="line">      length: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.addClass = function(classs) &#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      nodes[i].classList.add(classs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.setText = function(text)&#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        nodes[i].textContent = text;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.$ = jQuery</span><br><span class="line"></span><br><span class="line">var $div = $(&apos;div&apos;)</span><br><span class="line">$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red</span><br><span class="line">$div.setText(&apos;222&apos;) // 可将所有 div 的 textContent 变为 hi</span><br></pre></td></tr></table></figure><h2 id="代码实现过程"><a href="#代码实现过程" class="headerlink" title="代码实现过程"></a>代码实现过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = function(nodeOrSelector)</span><br></pre></td></tr></table></figure><ul><li>一般我们的得到的元素都是一个dom对象，而这个对象最终继承的就是Node接口</li><li>所以可以在 Node.prototype 上添加以上 addClass 及setText 方法</li><li>但是Node.prototype 是一个共有对象，每个人写的程序都不一样， 如果大家都在这里面操作添加删除API  ,   就会出现各种问题</li><li>所以我们可以取一个我们自己喜欢的名字来当作我们简便操作dom树，这个构造函数就不会被别人乱修改啦，而jQuery的作者就取名叫jQuery的</li><li>为了更懒更简便的操作，所以让$ = jQuery</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let nodes = &#123;&#125;</span><br><span class="line">  if (typeof nodeOrSelector === &apos;string&apos;) &#123;</span><br><span class="line">    let tmp = document.querySelectorAll(nodeOrSelector);</span><br><span class="line">    for(var i =0; i &lt; tmp.length; i++)&#123;</span><br><span class="line">      nodes[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.length = i;</span><br><span class="line">  &#125; else if (nodeOrSelector instanceof Node) &#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      0: nodeOrSelector,</span><br><span class="line">      length: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>因为jQuery 传入的有可能是字符串形式的选择器 或者 节点元素，所以   这段代码实现的功能是</li><li>先创建一个对象</li><li>判断传入的参数是字符串还是dom对象</li><li>如果是字符串就document.querySelectorAll匹配所有符合的选择器的元素，然后改成jQuery形式的对象，也就是我们开始创建的对象，不能直接复制给这个对象，因为匹配得到的对象是NodeList对象，是dom类型对象</li><li>如果是节点元素就直接添加进第一项就好了</li><li>因为jQuery ,$div[0] === div</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nodes.addClass = function(classs) &#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      nodes[i].classList.add(classs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.setText = function(text)&#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        nodes[i].textContent = text;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nodes;</span><br></pre></td></tr></table></figure><ul><li>最后就是给这个要返回的对象添加API啦</li><li>真正的jQuery的API都是封装在jQuery.prototype中，所有的jQuery对象都共用这些API</li><li>这里的nodes就与两个方法之间产生了闭包， 保护了nodes的私有化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.$ = jQuery</span><br><span class="line"></span><br><span class="line">var $div = $(&apos;div&apos;)</span><br><span class="line">$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red</span><br><span class="line">$div.setText(&apos;222&apos;) // 可将所有 div 的 textContent 变为 hi</span><br></pre></td></tr></table></figure><ul><li>为了更方便的操作 用<code>$</code>代替jQuery  ，<code>var $div = $(&#39;div&#39;)</code> 可以 <code>var $div = jQuery(&#39;div&#39;)</code> 也是一样的</li><li>构造函数返回的对象就包含了两个方法，  我们就可以直接调用啦， </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解jQuery&quot;&gt;&lt;a href=&quot;#深入理解jQuery&quot; class=&quot;headerlink&quot; title=&quot;深入理解jQuery&quot;&gt;&lt;/a&gt;深入理解jQuery&lt;/h1&gt;&lt;h2 id=&quot;自我封装jQuery代码&quot;&gt;&lt;a href=&quot;#自我封装jQuer
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础排序" scheme="https://hongtao-huang.github.io/tags/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>登陆注册与cookie</title>
    <link href="https://hongtao-huang.github.io/cookie/"/>
    <id>https://hongtao-huang.github.io/cookie/</id>
    <published>2018-06-27T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="登陆注册与cookie"><a href="#登陆注册与cookie" class="headerlink" title="登陆注册与cookie"></a>登陆注册与cookie</h1><h2 id="登陆注册流程"><a href="#登陆注册流程" class="headerlink" title="登陆注册流程"></a>登陆注册流程</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><ol><li>提供表单输入</li><li>用户提交 发送post请求</li><li>请求数据带有用户的 注册账号 及 密码等</li><li>可以在前端检查处理用户的注册信息是否有问题</li></ol><h4 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h4><ol><li>设置好路由供请求访问</li><li>处理请求信息，将用户发送的数据提取</li><li>可以在后台检查处理用户的注册信息是否有问题，后响应给前端</li><li>在数据中查找，判断注册用户是否存在 </li><li>将用户的正确的注册信息存储进数据库</li><li>响应注册成功</li></ol><h3 id="登入"><a href="#登入" class="headerlink" title="登入"></a>登入</h3><h4 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h4><ol><li>提供表单输入</li><li>用户提交 发送post请求</li><li>请求数据带有用户的 登入账号 及 密码等</li></ol><h4 id="后台-1"><a href="#后台-1" class="headerlink" title="后台"></a>后台</h4><ol><li>设置好路由供请求访问</li><li>处理请求信息，将用户发送的数据提取</li><li>检查处理用户登入的信息是否有问题，后响应给前端</li><li>在数据中查找，判断登入用户是否存在并且密码是否正确 </li><li>响应头中set-cookie（设置cookie）</li><li>这时浏览器中会保存这个cookie信息</li><li>响应登入成功</li></ol><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ol><li>cookie 是有时效性的</li><li>cookie 是保存在那个使用访问的浏览器中的 ，所以换一个浏览器还是需要重新登录，然后设置cookie</li><li>cookie关闭浏览器就删掉了， 但是可以设置不删掉，或者存留时间</li><li>在cookie没有被删除之前，同源域名的申请每一次都会带上这个cookie</li><li>也就是这个请求的请求头中会自动带上这个cookie</li><li>而访问的页面会根据cookie的值来判断是否登陆</li><li>从而给出不同的页面或者相同的页面不一样的使用权限等</li><li>所以cookie是保存用户登陆信息的东西</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;登陆注册与cookie&quot;&gt;&lt;a href=&quot;#登陆注册与cookie&quot; class=&quot;headerlink&quot; title=&quot;登陆注册与cookie&quot;&gt;&lt;/a&gt;登陆注册与cookie&lt;/h1&gt;&lt;h2 id=&quot;登陆注册流程&quot;&gt;&lt;a href=&quot;#登陆注册流程&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="闭包" scheme="https://hongtao-huang.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>原型</title>
    <link href="https://hongtao-huang.github.io/%E5%8E%9F%E5%9E%8B/"/>
    <id>https://hongtao-huang.github.io/原型/</id>
    <published>2018-06-16T15:00:00.000Z</published>
    <updated>2018-12-19T02:34:06.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>学习<code>Javascript</code>之初总是被<code>__proto__</code> 与 <code>prototype</code> 这两个属性绕晕了， 所以先在此列出常见的各指向情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var num = 1</span><br><span class="line">   num.__proto__ === Number.prototype</span><br><span class="line">   num.__proto__.__proto__ === Object.prototype</span><br><span class="line">   num.__proto__.constructor === Number</span><br><span class="line">   Number.prototype.__proto__ === Object.prototype</span><br><span class="line">   Number.prototype.constructor === Number</span><br><span class="line">   </span><br><span class="line">   var fn = function()&#123;&#125;</span><br><span class="line">   fn.__proto__ === Function.prototype</span><br><span class="line">   fn.__proto__.__proto__ === Object.prototype</span><br><span class="line">   fn.__proto__.constructor === Function</span><br><span class="line">   Function.prototype.__proto__ === Object.prototype</span><br><span class="line">   Function.prototype.constructor === Function</span><br><span class="line"></span><br><span class="line">   var array = []</span><br><span class="line">   array.__proto__ === Array.prototype</span><br><span class="line">   array.__proto__.__proto__ === Object.prototype</span><br><span class="line">   array.__proto__.constructor === Array</span><br><span class="line">   Array.prototype.__proto__ === Object.prototype</span><br><span class="line">   Array.prototype.constructor === Array</span><br><span class="line"></span><br><span class="line">   var bool = true</span><br><span class="line">   bool.__proto__ === Boolean.prototype</span><br><span class="line">   bool.__proto__.__proto__ === Object.prototype</span><br><span class="line">   bool.__proto__.constructor === Boolean/**/</span><br><span class="line">   Boolean.prototype.__proto__ === Object.prototype</span><br><span class="line">   Boolean.prototype.constructor === Boolean</span><br><span class="line"></span><br><span class="line">   var str = &quot;String&quot;</span><br><span class="line">   str.__proto__ === String.prototype</span><br><span class="line">   str.__proto__.__proto__ === Object.prototype</span><br><span class="line">   str.__proto__.constructor === String</span><br><span class="line">   String.prototype.__proto__ === Object.prototype</span><br><span class="line">   String.prototype.constructor === String</span><br><span class="line">   </span><br><span class="line">   var object = &#123;&#125;</span><br><span class="line">   object.__proto__ === Object.prototype</span><br><span class="line">   object.__proto__.__proto__ === null</span><br><span class="line">   object.__proto__.constructor === Object</span><br><span class="line">   Object.prototype.__proto__ === null</span><br><span class="line">   Object.prototype.constructor === Object</span><br></pre></td></tr></table></figure></p><p>运行都为<code>true</code>，从以上代码一步步讲解<code>实例</code>，<code>原型</code>，<code>原型链</code>，<code>构造函数</code>，<code>构造函数</code>属性，<code>new</code>指令 及 js<code>一切皆对象</code>的误解</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li><p>JS中以上代码会用到的几个构造函数分别是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function，Number，Boolean，String，Object</span><br></pre></td></tr></table></figure></li><li><p>而这些构造函数都是由 <code>Function</code>构造出来的， 所以</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.__proto__ === Function.prototype // 为 true</span><br><span class="line">Array.__proto__ === Function.prototype // 为 true</span><br><span class="line">Object.__proto__ === Function.prototype // 为 true</span><br><span class="line">Number.__proto__ === Function.prototype</span><br><span class="line">Boolean.__proto__ === Function.prototype</span><br><span class="line">String.__proto__ === Function.prototype</span><br></pre></td></tr></table></figure></li><li><p>以上第一句代码 <code>var num = 1</code> 其实应该这样写 <code>var num = new Number(1)</code> , 那么为什么 直接赋值num还是可以使用很多<code>Number</code>的方法呢</p></li><li>因为JS在使用num的时候会创建一个临时的Number（1）给num ，然后num就可以正常使用Number的方法，本质上num还是基础数据类型，而不是混合数据类型的对象形式</li><li>那么为什么要使用new呢 </li><li><p>当一个函数New的时候 会执行以下几步</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//使用new 会有以下四个步骤</span><br><span class="line">   function fn()&#123;</span><br><span class="line">        1.  创建一个临时对象</span><br><span class="line">        var temp  = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        2.  临时对象__proto__ =  fn.原型</span><br><span class="line">        temp.__proto__ = fn.prototype</span><br><span class="line"></span><br><span class="line">        3. 返回这个临时对象</span><br><span class="line">        return temp </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fn.prototype = &#123;</span><br><span class="line">       constructor ： fn</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>那么执行完 <code>var num = new Number(1)</code> 后 num就是一个对象了， 而这个对象里面有一个<code>__proto__</code>的属性 。</p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>所以实例就是： 执行构造函数后得到的这个对象</p><h2 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h2><p>而原型就是： 实例<code>__proto__</code>属性指向的 该函数的 <code>prototype</code>属性也是一个对象</p><h2 id="构造函数属性"><a href="#构造函数属性" class="headerlink" title="构造函数属性"></a>构造函数属性</h2><p>构造函数属性<code>constructor</code>指向该构造函数本身</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>而 原型链就是 <code>num.__proto__.__proto__.__proto__ === null</code> 这条链所对应的值</p><h2 id="读取属性"><a href="#读取属性" class="headerlink" title="读取属性"></a>读取属性</h2><p>当我们读取属性时， 从实例对象的属性开始找，如果实例属性中没有需要的属性，就去原型中找，如果该原型中还是没有，又会继续往下一层原型中找，直到顶层为止。 <code>num.__proto__.__proto__.__proto__ === null</code>只想null的时候</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>所有的构造函数都是由Function构造函数所构造出来的 <code>Array.__proto__ === Function.prototype</code></li><li>所有的实例对象的<code>__proto__</code>属性都指向该构造函数的<code>prototype</code>属性<code>array.__proto__ === Array.prototype</code></li><li>所有的实例对象的<code>__proto__.__proto__</code>属性都指向的构造函数Object的<code>prototype</code>属性<code>num.__proto__.__proto__ === Object.prototype</code></li><li>所有的原型的<code>constructor</code>属性都指向该构造函数<code>num.__proto__.constructor === Number</code></li><li>所有<code>Number.prototype.__proto__ === Object.prototype</code></li><li>Object的实例对象的<code>__proto__.__proto__</code> 为null</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h1&gt;&lt;p&gt;学习&lt;code&gt;Javascript&lt;/code&gt;之初总是被&lt;code&gt;__proto__&lt;/code&gt; 与 &lt;code&gt;prototype
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="\__proto__ , prototype" scheme="https://hongtao-huang.github.io/tags/proto-prototype/"/>
    
  </entry>
  
  <entry>
    <title>call,apply,bind用法</title>
    <link href="https://hongtao-huang.github.io/call,apply,bind%E7%94%A8%E6%B3%95/"/>
    <id>https://hongtao-huang.github.io/call,apply,bind用法/</id>
    <published>2018-05-28T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="call-apply-bind用法"><a href="#call-apply-bind用法" class="headerlink" title="call,apply,bind用法"></a>call,apply,bind用法</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">   name: &apos;hht&apos;,</span><br><span class="line">   age : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(name,age)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">  console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.call(obj,&apos;mmd&apos;,18);</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fromntpn9mj305i02za9v.jpg" alt=""></p><ul><li>call()方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表).</li><li>call 的第一个参数是指定调用的这个函数的this ，非严格模式下this的值如果是null或者undefine ，那么这个this指向window</li><li>call 第二个以及之后的参数就是我们的arguments的值</li></ul><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">   name: &apos;hht&apos;,</span><br><span class="line">   age : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(name,age)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">  console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.apply(obj,[&apos;mmd&apos;,18]);</span><br><span class="line">f.apply(obj,&#123;0: &apos;mmd&apos;, 1: 18, length: 2&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frompayhl9j304s03u3yb.jpg" alt=""></p><ul><li>call()方法的作用和 apply() 方法类似，只有一个区别，就是 call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组, 或伪数组。</li></ul><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">   name: &apos;hht&apos;,</span><br><span class="line">   age : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">  for(let i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    console.log(arguments[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f1Bind = f.bind(obj,&apos;hht&apos;,18);</span><br><span class="line">f1Bind();</span><br><span class="line">f1Bind(1,2);</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fromlqepfyj30au078mx7.jpg" alt=""></p><ul><li>bind 绑定时接受的参数跟 call 一致.</li><li>bind 不会立即调用，它会生成一个新的函数，你想什么时候调就什么时候调。</li><li>bind 绑定好的this不会改变</li><li>bind 绑定时的给的参数会成为这个绑定函数的固定参数，调用这个函数时这几个参数一定会在</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;call-apply-bind用法&quot;&gt;&lt;a href=&quot;#call-apply-bind用法&quot; class=&quot;headerlink&quot; title=&quot;call,apply,bind用法&quot;&gt;&lt;/a&gt;call,apply,bind用法&lt;/h1&gt;&lt;h2 id=&quot;call&quot;
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="call apply bind" scheme="https://hongtao-huang.github.io/tags/call-apply-bind/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="https://hongtao-huang.github.io/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85-%E9%97%AD%E5%8C%85%E7%9A%84%E7%94%A8%E9%80%94/"/>
    <id>https://hongtao-huang.github.io/什么是闭包-闭包的用途/</id>
    <published>2018-05-27T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function 函数()&#123;</span><br><span class="line">    var 变量  = 1；</span><br><span class="line">    function 内部函数()&#123;</span><br><span class="line">        console.log(变量);</span><br><span class="line">    &#125;</span><br><span class="line">    return 内部函数;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中</p><ul><li>内部函数 + 变量（内部函数能访问到这个变量） =  闭包</li><li>return  内部函数只是为了能使用到这个内部函数 ， 也就是能使用闭包</li><li>函数套函数是为了隐藏一个变量 或者说这就是闭包的作用</li></ul><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function create()</span><br><span class="line">&#123;</span><br><span class="line">  var n=999;</span><br><span class="line">  return &#123;</span><br><span class="line">    set : function(aaa)&#123;</span><br><span class="line">        n = aaa;</span><br><span class="line">    &#125;,</span><br><span class="line">    get : function()&#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = create();</span><br><span class="line">var b = create();</span><br><span class="line">a.set(2);</span><br><span class="line">console.log(a.get());</span><br><span class="line">console.log(b.get());</span><br></pre></td></tr></table></figure><ul><li>闭包的作用就是间接的访问一个变量 ，隐藏一个变量</li><li>去掉那个外层函数  变量就会很容易被直接使用并且修改</li><li>n 是一个局部变量 ，在函数外面是使用不到这个变量的</li><li>这时候get 和 set  函数就是 用来间接访问这个变量的访问器</li><li>闭包和变量的作用域有关</li></ul><p>在我们写js代码的时候会很容易就出现闭包， 而不是我们经常有意的去创造闭包<br>引用维基百科：闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h1&gt;&lt;h2 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="闭包" scheme="https://hongtao-huang.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配</title>
    <link href="https://hongtao-huang.github.io/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    <id>https://hongtao-huang.github.io/移动端适配/</id>
    <published>2018-05-26T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h1><h2 id="meta-viewport"><a href="#meta-viewport" class="headerlink" title="meta viewport"></a>meta viewport</h2><p> <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</code><br>viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</code><br>目前主流浏览器使用<br>initial-scale属性控制页面最初加载时的缩放等级。maximum-scale、minimum-scale及user-scalable属性控制允许用户以怎样的方式放大或缩小页面。</p><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><ul><li>我的理解就是用来辨别屏幕大小从而来使用不同的css样式达到大小屏幕的自适应</li></ul><ul><li><p>例如 iphone5/5s 屏幕宽度为 320 iphone6/7/8 屏幕宽度为 375</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- link元素中的CSS媒体查询 --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 320px)&quot; href=&quot;iphone5.css&quot; /&gt;</span><br><span class="line"> &lt;link rel=&quot;stylesheet&quot; media=&quot;(min-width: 321px) and (max-width: 375px)&quot; href=&quot;iphone678.css&quot; /&gt;</span><br></pre></td></tr></table></figure><p>以上例子就是当屏幕最大为320px时 使用iphone.css<br>以上例子就是当屏幕最小321px最大为375px时 使用iphone678.css  </p><p> 也可以在css中给某些元素设置  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- 样式表中的CSS媒体查询 --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">@media (max-width: 320px) &#123;</span><br><span class="line">.nav &#123;</span><br><span class="line">  display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li>而有些公司对于移动端的适配 都是后台开发人员根据屏幕的尺寸来使用 不同的html ， 如写代码啦  </li><li>还有比如淘宝的适配就是不同的设备访问的网站不同  比如电脑访问淘宝就是taobao.com  ,手机访问就是m.taobao.com</li></ul><h2 id="动态REM"><a href="#动态REM" class="headerlink" title="动态REM"></a>动态REM</h2><ul><li>为了在不同的手机页面显示的内容及布局都是一样的 ， 比如说 iphone5 宽度是320px<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frnge6bj39j30ah09d748.jpg" alt=""><br>iphone6 宽度是375px<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frngfzkmpkj30bn09ewef.jpg" alt=""><br>整体的显示效果是一样的，苹果6会显示的大一点。 网页会随着不同的手机而进行等比的放大与缩小，那么动态rem就是用来解决这个 问题的</li></ul><h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><pre><code>常用的有  </code></pre><ul><li>px  就是像素点的意思</li><li>em  一个M的大小 ，或者不是很正确的一个汉字大小 ，相对于当前元素的font-size</li><li>vh  视口高度的1/100，其次，它不像rem那样被广泛支持。</li><li>vw  视口宽度的1/100，其次，它不像rem那样被广泛支持。</li><li>rem root em 根的em  ，一个文档的根是html  ，也就是1rem === html的font-size</li></ul><h3 id="计算rem"><a href="#计算rem" class="headerlink" title="计算rem"></a>计算rem</h3><ul><li><p>利用js获取页面宽度， 设置根元素的font-size  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var pageWidth = window.innerWidth;</span><br><span class="line">    document.write(&apos;&lt;style&gt;html&#123;font-size:&apos;+ pageWidth/10 +&apos;px;&#125;&lt;/style&gt;&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>这样的话 1rem 就相当与 页面宽度的 10% ， 就能知道具体设置的宽高是多少</p></li><li><p>但是rem 如果根据设计师的设计搞来写 ， 算rem 会很麻烦 ， 于是就用到了sass 的 px2rem 函数计算</p></li><li><p>windows安装sass 方法<br>i 安装ruby<br><a href="https://rubyinstaller.org/downloads/" target="_blank" rel="noopener">下载ruby</a>  下载最新版本<br>在命令行中输入<code>ruby -v</code>命令来确认是否安装成功：<br>ii 安装sass<br>Sass是Ruby语言写的，安装Sass必须先安装Ruby。假定你已经安装好了Ruby，接着在命令行输入下面的命令：<br><code>gem install sass</code> ，安装完成后，通过<code>sass -v</code>命令来判断是否安装成功</p><p>装好后 可以在scss 文件中写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$rem: 640;    // 设计稿的宽度</span><br><span class="line">@function px2rem($px) &#123;</span><br><span class="line">  @return ($px / $rem) * 10 + rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">  width: px2rem(320px);  // 算出来的 width: 5rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;移动端适配&quot;&gt;&lt;a href=&quot;#移动端适配&quot; class=&quot;headerlink&quot; title=&quot;移动端适配&quot;&gt;&lt;/a&gt;移动端适配&lt;/h1&gt;&lt;h2 id=&quot;meta-viewport&quot;&gt;&lt;a href=&quot;#meta-viewport&quot; class=&quot;header
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="meta-viewport media rem" scheme="https://hongtao-huang.github.io/tags/meta-viewport-media-rem/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="https://hongtao-huang.github.io/flex/"/>
    <id>https://hongtao-huang.github.io/flex/</id>
    <published>2018-05-23T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h1><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰-Flex布局</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">阮一峰-Flex布局实例教程</a></p><h2 id="Flex布局-1"><a href="#Flex布局-1" class="headerlink" title="Flex布局"></a>Flex布局</h2><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</li></ul><h2 id="Flex布局属性"><a href="#Flex布局属性" class="headerlink" title="Flex布局属性"></a>Flex布局属性</h2><ul><li>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</li><li>主轴：水平线 </li><li>交叉轴：垂直线</li></ul><h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><ul><li>决定主轴的方向 或  交叉轴的方向<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">   // flex-direction: row;  从左至右</span><br><span class="line">        // flex-direction: row-reverse;  从右至左</span><br><span class="line">        // flex-direction: column;  从上至下</span><br><span class="line">        // flex-direction: column-reverse;  从下至上</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h3><ul><li>决定如何换行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    //flex-wrap: nowrap;     不换行</span><br><span class="line">        //flex-wrap: wrap;    换行，第一行在上方（从上往下）</span><br><span class="line">        //flex-wrap: wrap-reverse;  换行，第一行在下方（从下往上）</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h3><ul><li><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line"> // flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">    // flex-flow: row nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h3><ul><li>决定了项目的水平对齐方式</li><li>与 主轴的方向有关，以下假设为<code>flex-direction: row;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  // justify-content: flex-start;   左对齐</span><br><span class="line">  // justify-content: flex-end;    右对齐</span><br><span class="line">  // justify-content: center;     居中对齐</span><br><span class="line">  // justify-content: space-between;  两端对齐，项目之间的间隔都相等。</span><br><span class="line">  // justify-content: space-around; 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h3><ul><li>决定了项目的垂直对齐方式</li><li>与交叉轴的方向有关，以下假设为<code>flex-direction: column;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// align-items: flex-start 上对齐</span><br><span class="line">// align-items: flex-end：下对齐</span><br><span class="line">// align-items: center：居中对齐</span><br><span class="line">// align-items: baseline: 项目的第一行文字的基线对齐。</span><br><span class="line">// align-items: stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br></pre></td></tr></table></figure></li></ul><h3 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h3><ul><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line"> // align-content: flex-start;  与交叉轴的起点对齐。</span><br><span class="line"> // align-content: flex-end;    与交叉轴的终点对齐。</span><br><span class="line"> // align-content: center;与交叉轴的中点对齐。</span><br><span class="line"> // align-content: space-between;  与交叉轴两端对齐，轴线之间的间隔平均分布。</span><br><span class="line"> // align-content: space-around;  每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span><br><span class="line"> // align-content: stretch;  轴线占满整个交叉轴。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">order : 0123...（优先级设置） 项目的排列顺序</span><br><span class="line">flex-grow：0123...（默认为0,不放大） 项目的放大比例，自动按比列分配容器空间</span><br><span class="line">flex-shrink：0123...（默认为1,默认空间不足时可等比缩放，为0不缩）</span><br><span class="line">flex-basis：length | auto 设置项目的主轴空间（main size） ，auto 为项目的本来大小</span><br><span class="line">flex： 前三个的省略写法属性 ，两个快捷值 auto（1  1 auto） none （0 0 auto）</span><br><span class="line">align-self：auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flex布局&quot;&gt;&lt;a href=&quot;#Flex布局&quot; class=&quot;headerlink&quot; title=&quot;Flex布局&quot;&gt;&lt;/a&gt;Flex布局&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-g
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="flex" scheme="https://hongtao-huang.github.io/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>文字溢出省略文本对齐垂直居中margin合并</title>
    <link href="https://hongtao-huang.github.io/%E6%96%87%E5%AD%97%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <id>https://hongtao-huang.github.io/文字溢出省略文本对齐垂直居中/</id>
    <published>2018-05-19T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文字溢出省略文本对齐垂直居中margin合并"><a href="#文字溢出省略文本对齐垂直居中margin合并" class="headerlink" title="文字溢出省略文本对齐垂直居中margin合并"></a>文字溢出省略文本对齐垂直居中margin合并</h1><h2 id="文本超出溢出以及如何添加省略号"><a href="#文本超出溢出以及如何添加省略号" class="headerlink" title="文本超出溢出以及如何添加省略号"></a>文本超出溢出以及如何添加省略号</h2><h3 id="一行文本"><a href="#一行文本" class="headerlink" title="一行文本"></a>一行文本</h3><h4 id="默认情况下"><a href="#默认情况下" class="headerlink" title="默认情况下"></a>默认情况下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    div&#123;</span><br><span class="line">     width:100px;</span><br><span class="line">     border: 1px solid red;</span><br><span class="line">      </span><br><span class="line">     /* white-space:nowrap; */   /*不换行，超出div宽度的文字溢出*/</span><br><span class="line">     /* overflow:hidden; */         /* 超出宽度部分自动隐藏 */</span><br><span class="line">     /* text-overflow:ellipsis; */   /*超出部分变成省略号*/</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii nihaoninnnn你好</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgfunzpr7j306h02jt8i.jpg" alt=""></p><ul><li>第一行没有换行是因为浏览器把它看成一个英文单词</li><li>所以从现象可以看出默认超出宽度是会换行的</li></ul><h4 id="不换行，超出div宽度的文字溢出"><a href="#不换行，超出div宽度的文字溢出" class="headerlink" title="不换行，超出div宽度的文字溢出"></a>不换行，超出div宽度的文字溢出</h4><p>恢复<code>white-space:nowrap;</code> 这个属性<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgfxlji7zj309s01djr6.jpg" alt=""></p><h4 id="超出部分隐藏，超出部分变省略号"><a href="#超出部分隐藏，超出部分变省略号" class="headerlink" title="超出部分隐藏，超出部分变省略号"></a>超出部分隐藏，超出部分变省略号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">overflow:hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgg18sblhj305l01a0ru.jpg" alt=""></p><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">     width:100px;</span><br><span class="line">     border: 1px solid red;</span><br><span class="line">      </span><br><span class="line">     display: -webkit-box;</span><br><span class="line">  -webkit-line-clamp: 3;   /*最多显示三行文本，超出就变省略号*/</span><br><span class="line">  -webkit-box-orient: vertical;  </span><br><span class="line">   overflow:hidden;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii nihaoninnnn你好范德萨发热管杜莎夫人</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgg504w73j304r032glg.jpg" alt=""></p><h2 id="多行文本两端对齐"><a href="#多行文本两端对齐" class="headerlink" title="多行文本两端对齐"></a>多行文本两端对齐</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    span&#123;</span><br><span class="line">  display:inline-block;</span><br><span class="line">  width:4em;</span><br><span class="line">  text-align:justify;   /*文本换行对齐*/</span><br><span class="line">  font-size:20px;</span><br><span class="line">  line-height:20px;</span><br><span class="line">&#125;</span><br><span class="line">span::after&#123;</span><br><span class="line">  content:&apos;&apos;;</span><br><span class="line">  display:inline-block;</span><br><span class="line">  width:100%;</span><br><span class="line">&#125;  </span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;span&gt;姓名&lt;/span&gt; &lt;br&gt;</span><br><span class="line">  &lt;span&gt;联系方式&lt;/span&gt; &lt;br&gt;</span><br><span class="line">  &lt;span&gt;炸弹人&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frggd20paij304x03dt8k.jpg" alt=""></p><h2 id="文字垂直居中"><a href="#文字垂直居中" class="headerlink" title="文字垂直居中"></a>文字垂直居中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">   div&#123;</span><br><span class="line">     border: 1px solid red;</span><br><span class="line">    line-height:30px;</span><br><span class="line">    padding:5px 0</span><br><span class="line">&#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">文字垂直居中</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frggggrzvkj307j02ojr6.jpg" alt=""></p><ul><li>遵循一条原则  能不用height 就别用 ，用padding撑起想要的高度</li></ul><h2 id="容器垂直居中"><a href="#容器垂直居中" class="headerlink" title="容器垂直居中"></a>容器垂直居中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    body&#123;</span><br><span class="line">      box-sizing:border-box;</span><br><span class="line">    &#125;</span><br><span class="line">    .dad&#123;</span><br><span class="line">      border: 2px solid blue;</span><br><span class="line">      height: 100vh;</span><br><span class="line">      display: flex;</span><br><span class="line">      justify-content: center;</span><br><span class="line">      align-items: center;</span><br><span class="line">    &#125;</span><br><span class="line">    .son&#123;</span><br><span class="line">      border:3px solid red;</span><br><span class="line">      width: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;dad&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;son&quot;&gt;</span><br><span class="line">      fdksfdlmks sdfefdsfdsfwef</span><br><span class="line">      fdfwdfsefrf</span><br><span class="line">      dfrefdreg</span><br><span class="line">      fefdsgrdsfs</span><br><span class="line">      fdefregr</span><br><span class="line">      dgersd</span><br><span class="line">      gre</span><br><span class="line">      dfwe</span><br><span class="line">      fd</span><br><span class="line">      fe</span><br><span class="line">      dfd</span><br><span class="line">      erfrgrgfdsrgf</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgpt4sz6gj30e80ozaai.jpg" alt=""></p><ul><li>新时代前端记住这种用flex 布局来垂直居中，就好了</li></ul><h2 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a>margin合并</h2><h3 id="两个div之间的margin合并"><a href="#两个div之间的margin合并" class="headerlink" title="两个div之间的margin合并"></a>两个div之间的margin合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">      box-sizing:border-box;</span><br><span class="line">    &#125;</span><br><span class="line">   .div1&#123;</span><br><span class="line">     border: 1px solid red;</span><br><span class="line">     height:100px;</span><br><span class="line">     margin:10px 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .div2&#123;</span><br><span class="line">      height:100px;</span><br><span class="line">      border:1px solid green;</span><br><span class="line">      margin:10px 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=div1&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=div2&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgmolf25bj30k30bbmxn.jpg" alt=""></p><ul><li>两个div 分别给了10px的margin</li><li>两个div之间的间距按照直觉应该是20px</li><li>通过开发者工具我们可以看到它们之间只有10px</li><li>这就说明他们的margin合并了</li></ul><h3 id="父子div的margin合并"><a href="#父子div的margin合并" class="headerlink" title="父子div的margin合并"></a>父子div的margin合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">      box-sizing:border-box;</span><br><span class="line">    &#125;</span><br><span class="line">    body&#123;</span><br><span class="line">      border: 1px solid blue;</span><br><span class="line">    &#125;</span><br><span class="line">   .dad&#123;</span><br><span class="line">     outline: 1px solid red;</span><br><span class="line">     margin:10px 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .son&#123;</span><br><span class="line">      height:100px;</span><br><span class="line">      border:1px solid green;</span><br><span class="line">      margin:20px 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=dad&gt;</span><br><span class="line">    &lt;div class=son&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgmwwqo4ej30kt0btt98.jpg" alt=""></p><ul><li>父元素margin为10px 子元素margin为20px </li><li>正常的想法应该是子元素在父元素中离父元素边框有20px的间距，而父元素离body的边框有10px的间距</li><li>通过开发者工具我们可以看到子元素的margin超出了父元素边框并且离body间距是20px</li><li>这就说明子元素与父元素的margin合并了</li><li>注意这里父元素的边框线用的是outline</li></ul><h3 id="那么为什么呢？"><a href="#那么为什么呢？" class="headerlink" title="那么为什么呢？"></a>那么为什么呢？</h3><h4 id="将父元素的边框设置为border，或者给父元素加一padding"><a href="#将父元素的边框设置为border，或者给父元素加一padding" class="headerlink" title="将父元素的边框设置为border，或者给父元素加一padding"></a>将父元素的边框设置为border，或者给父元素加一padding</h4><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgn7hvoclj30ec05gmwy.jpg" alt=""></p><ul><li>就会发现神奇的好了</li></ul><h4 id="在两个div之间再加一个div-设置border或者padding"><a href="#在两个div之间再加一个div-设置border或者padding" class="headerlink" title="在两个div之间再加一个div 设置border或者padding"></a>在两个div之间再加一个div 设置border或者padding</h4><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgndw6rl6j30eq074dfn.jpg" alt=""></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>因此总结一下就是</li><li>两个元素的margin合并是因为中间没有阻挡它们的属性就会合并在一起</li><li>比如说border就是一堵墙，堵在两个margin之间就不会合并了</li><li>或者说margin碰到关于border/padding这种元素，就是距离这个元素的margin有多少</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文字溢出省略文本对齐垂直居中margin合并&quot;&gt;&lt;a href=&quot;#文字溢出省略文本对齐垂直居中margin合并&quot; class=&quot;headerlink&quot; title=&quot;文字溢出省略文本对齐垂直居中margin合并&quot;&gt;&lt;/a&gt;文字溢出省略文本对齐垂直居中margin
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="https://hongtao-huang.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Js插入排序</title>
    <link href="https://hongtao-huang.github.io/%E6%8E%92%E5%BA%8F-%E6%8F%92%E5%85%A5-%E8%AE%A1%E6%95%B0-%E5%9F%BA%E6%95%B0/"/>
    <id>https://hongtao-huang.github.io/排序-插入-计数-基数/</id>
    <published>2018-05-04T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js插入排序"><a href="#Js插入排序" class="headerlink" title="Js插入排序"></a>Js插入排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序原理"><a href="#插入排序原理" class="headerlink" title="插入排序原理"></a>插入排序原理</h3><ul><li>用未参与排序的数与已经排好序的数从后往前做比较</li><li>比较中找到自己的位置然后插入到该位置<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqz4z2kuuyg30b00f5n4e.jpg" alt=""><h3 id="插入排序步骤"><a href="#插入排序步骤" class="headerlink" title="插入排序步骤"></a>插入排序步骤</h3></li><li>确定外层循环 index为已排好序的个数</li><li>内层循环从已排好序的最后位置开始往前比较</li><li>整个已排序部分搜索一遍保存最后的索引</li><li>插入 splice函数</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = [10,38,45,50,48,13,27,20];</span><br><span class="line">var index = 0;</span><br><span class="line">for(var i = 1; i &lt; a.length; i ++)&#123;</span><br><span class="line">  index = i;</span><br><span class="line">    for(var j = i - 1; j &gt;= 0; j--)&#123;</span><br><span class="line">        if(a[i] &lt; a[j] )&#123;</span><br><span class="line">            index = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.splice(index,0,a[i]);  //插入a[i]</span><br><span class="line">    a.splice(i+1,1);  // 由于数组变了，所以原先a[i]的值到a[i+1]去了，删掉它</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Js插入排序&quot;&gt;&lt;a href=&quot;#Js插入排序&quot; class=&quot;headerlink&quot; title=&quot;Js插入排序&quot;&gt;&lt;/a&gt;Js插入排序&lt;/h1&gt;&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础排序" scheme="https://hongtao-huang.github.io/tags/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Js冒泡排序&amp;选择排序</title>
    <link href="https://hongtao-huang.github.io/Js%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://hongtao-huang.github.io/Js冒泡排序选择排序/</id>
    <published>2018-05-03T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js冒泡排序-amp-选择排序"><a href="#Js冒泡排序-amp-选择排序" class="headerlink" title="Js冒泡排序&amp;选择排序"></a>Js冒泡排序&amp;选择排序</h1><h2 id="冒泡排序原理"><a href="#冒泡排序原理" class="headerlink" title="冒泡排序原理"></a>冒泡排序原理</h2><ul><li>两相邻的数依次比较</li><li>若从小到大排列两两比较时前一个数比后一个数大互换位置</li><li>相互比较完一轮最大的数就会到最后面，并且不再参与比较</li><li>循环比较 直到比较完成<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqy8ra7e3cg30d706vn7w.jpg" alt=""></li></ul><h2 id="冒泡排序步骤"><a href="#冒泡排序步骤" class="headerlink" title="冒泡排序步骤"></a>冒泡排序步骤</h2><ol><li>确定外层循环次数   数组的长度</li><li>确定内层循环的次数  每确定冒泡一个数内层循环减少一次 数组长度 减 外层循环的index </li><li>相邻两数相比较  前一个数比后一个数大 互换两数位置</li></ol><h2 id="冒泡排序代码实现"><a href="#冒泡排序代码实现" class="headerlink" title="冒泡排序代码实现"></a>冒泡排序代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = [36,26,27,2,4,19,50,48];</span><br><span class="line">var temp;</span><br><span class="line"></span><br><span class="line">for(var i= 0; i &lt;  a.length; i++)</span><br><span class="line">for(var j = 0; j &lt; a.length-i; j++)&#123;</span><br><span class="line">    if(a[j] &gt;  a[j+1])&#123;</span><br><span class="line">        temp = a[j];</span><br><span class="line">        a[j] = a[j+1];</span><br><span class="line">        a[j+1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><h2 id="选择排序原理"><a href="#选择排序原理" class="headerlink" title="选择排序原理"></a>选择排序原理</h2><ul><li>找未排序的元素中最小的数</li><li>将最小数与起始位置互换</li><li>直到排序完成<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqy96u2mbgg30gg06n7aa.jpg" alt=""></li></ul><h2 id="选择排序步骤"><a href="#选择排序步骤" class="headerlink" title="选择排序步骤"></a>选择排序步骤</h2><ol><li>确定外层循环次数 index为每一次寻找最小值的起始位置 直到数组长度</li><li>内层循环每次都是由起始位置 +1 直到数组长度</li><li>假设每一次的起始位置为最小数 碰到更小的用更小的和后面的数继续做比较</li><li>保存最小数的索引</li><li>内层循环结束后最小数与起始位置互换</li></ol><h2 id="选择排序代码实现"><a href="#选择排序代码实现" class="headerlink" title="选择排序代码实现"></a>选择排序代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a = [4,12,13,4,3,42,33,4,43,44];</span><br><span class="line">var temp;</span><br><span class="line">var minIndex;</span><br><span class="line"></span><br><span class="line">for(var i = 0; i &lt; a.length; i ++)&#123;</span><br><span class="line">    minIndex = i;</span><br><span class="line">    for(var j = i + 1; j &lt; a.length; j++)&#123;</span><br><span class="line">        if(a[minIndex] &gt; a[j])&#123;</span><br><span class="line">            minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = a[minIndex];</span><br><span class="line">    a[minIndex] = a[i];</span><br><span class="line">    a[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Js冒泡排序-amp-选择排序&quot;&gt;&lt;a href=&quot;#Js冒泡排序-amp-选择排序&quot; class=&quot;headerlink&quot; title=&quot;Js冒泡排序&amp;amp;选择排序&quot;&gt;&lt;/a&gt;Js冒泡排序&amp;amp;选择排序&lt;/h1&gt;&lt;h2 id=&quot;冒泡排序原理&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础排序冒泡法" scheme="https://hongtao-huang.github.io/tags/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E5%86%92%E6%B3%A1%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>css的position值</title>
    <link href="https://hongtao-huang.github.io/css%E7%9A%84position%E5%80%BC/"/>
    <id>https://hongtao-huang.github.io/css的position值/</id>
    <published>2018-04-27T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css的position值"><a href="#css的position值" class="headerlink" title="css的position值"></a>css的position值</h1><p>CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。</p><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><ul><li>正常的文档流会根据元素的类型来流动</li><li>内联元素会从左至右流动，显示不下去之后会换行继续从左向右</li><li>块级元素从上往下流动</li><li>脱离文档流的方法有浮动，绝对定位，固定定位</li></ul><h2 id="position5个取值"><a href="#position5个取值" class="headerlink" title="position5个取值"></a>position5个取值</h2><h3 id="static-相对定位"><a href="#static-相对定位" class="headerlink" title="static  相对定位"></a>static  相对定位</h3><blockquote><p>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</p></blockquote><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><blockquote><p>该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。<br>相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。相对定位的元素并未脱离文档流</p></blockquote><h3 id="absolute-绝对定位"><a href="#absolute-绝对定位" class="headerlink" title="absolute  绝对定位"></a>absolute  绝对定位</h3><blockquote><p>不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。<br>绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）,视窗。绝对定位的元素脱离了文档流</p></blockquote><h3 id="fixed-固定定位"><a href="#fixed-固定定位" class="headerlink" title="fixed 固定定位"></a>fixed 固定定位</h3><blockquote><p>不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform  属性非 none 时，容器由视口改为该祖先。<br>固定定位会固定显示在设置的位置，脱离了文档流</p></blockquote><h3 id="sticky-粘性定位"><a href="#sticky-粘性定位" class="headerlink" title="sticky 粘性定位"></a>sticky 粘性定位</h3><blockquote><p>盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。<br>粘性定位是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。例如：</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;css的position值&quot;&gt;&lt;a href=&quot;#css的position值&quot; class=&quot;headerlink&quot; title=&quot;css的position值&quot;&gt;&lt;/a&gt;css的position值&lt;/h1&gt;&lt;p&gt;CSS position属性用于指定一个元素在文档中
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="position" scheme="https://hongtao-huang.github.io/tags/position/"/>
    
  </entry>
  
  <entry>
    <title>CSS-元素宽高是由什么决定的</title>
    <link href="https://hongtao-huang.github.io/css%E5%AE%BD%E9%AB%98%E7%9A%84%E5%86%B3%E5%AE%9A/"/>
    <id>https://hongtao-huang.github.io/css宽高的决定/</id>
    <published>2018-04-13T12:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-元素宽高是由什么决定的"><a href="#CSS-元素宽高是由什么决定的" class="headerlink" title="CSS-元素宽高是由什么决定的"></a>CSS-元素宽高是由什么决定的</h1><blockquote><p> 任何元素都可以是块级元素 或 行内元素<br> 因为每个元素都可以设置成行内元素或块级元素   </p></blockquote><h2 id="行内元素表现形式"><a href="#行内元素表现形式" class="headerlink" title="行内元素表现形式"></a>行内元素表现形式</h2><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb3v2gjhvj309e01eq2q.jpg" alt=""><br>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br></pre></td></tr></table></figure></p><ul><li>行内元素就是在一行中显示，如果后面跟着的还是行内元素，就继续跟在后面显示，当一行不够显示时自动换行</li></ul><h2 id="块级元素表现形式"><a href="#块级元素表现形式" class="headerlink" title="块级元素表现形式"></a>块级元素表现形式</h2><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb423gjnaj309u02igld.jpg" alt=""><br>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;border: 1px solid red;&quot;&gt;123&lt;/div&gt;</span><br><span class="line">  &lt;div style=&quot;border: 1px solid red;&quot;&gt;123&lt;/div&gt;</span><br><span class="line">  &lt;div style=&quot;border: 1px solid red;&quot;&gt;123&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><ul><li>块级元素不管后面跟着的是什么元素，都会另起一行。也就是说块级元素会独占一行。<h2 id="元素的高度由什么决定的"><a href="#元素的高度由什么决定的" class="headerlink" title="元素的高度由什么决定的"></a>元素的高度由什么决定的</h2><h3 id="span-行内元素高度由什么决定的"><a href="#span-行内元素高度由什么决定的" class="headerlink" title="span 行内元素高度由什么决定的"></a>span 行内元素高度由什么决定的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    div&#123;</span><br><span class="line">      border: 1px solid blue;</span><br><span class="line">    &#125;</span><br><span class="line">    span&#123;</span><br><span class="line">      border: 1px solid red;</span><br><span class="line">      font-size: 72px;</span><br><span class="line">    &#125;</span><br><span class="line">    .s1&#123;</span><br><span class="line">       font-family: sans-serif;  </span><br><span class="line">    &#125;</span><br><span class="line">    .s2&#123;</span><br><span class="line">       font-family: monospace;</span><br><span class="line">    &#125;</span><br><span class="line">    .s3&#123;</span><br><span class="line">      font-family:serif ;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;span class=&quot;s1&quot;&gt;ABC&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;s2&quot;&gt;ABC&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;s3&quot;&gt;ABC&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb4g6bbdmj30fr02yt8r.jpg" alt=""></p><ul><li>可以看到， 我给每个span 都设置了一个字体， 而中间字体的高度明显高于两边的字体 。</li><li>每一种字体的设计师不一样， 每一种字体的设计师都会对自己设置出来的字体的默认行高不一样</li><li>所以，行内元素内容为字的元素的行高是由 字体的默认行高决定的。  </li><li>比较详细的解说可以看看这篇知乎文章<a href="https://zhuanlan.zhihu.com/p/27381252" target="_blank" rel="noopener">字号与行高</a></li></ul><h3 id="div-块级元素高度由什么决定的"><a href="#div-块级元素高度由什么决定的" class="headerlink" title="div 块级元素高度由什么决定的"></a>div 块级元素高度由什么决定的</h3><ul><li>从上面的程序代码可以看到， span是由一个div包裹的 。 div的告诉是中间最高的span的高度。</li><li>也就是说块级元素的高度是由它的内容决定的，而且是所有内容中最高的内容决定的。</li></ul><h2 id="元素的宽度是由什么决定的"><a href="#元素的宽度是由什么决定的" class="headerlink" title="元素的宽度是由什么决定的"></a>元素的宽度是由什么决定的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    div&#123;</span><br><span class="line">      border: 1px solid blue;</span><br><span class="line">      font-size: 72px;</span><br><span class="line">    &#125;</span><br><span class="line">    span&#123;</span><br><span class="line">      border: 1px solid red;</span><br><span class="line">      font-size: 72px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;span&gt;12345678&lt;/span&gt;</span><br><span class="line">    &lt;div&gt;12345678&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb50ogjyyj30g805jwep.jpg" alt=""></p><ul><li>行内元素的宽度是由它的内容决定的，行内元素不能设置宽高</li><li><p>块级元素当没有设置宽度是默认100%宽 ，所以才会到最右边。当设置了宽度是就是固定的宽度 ， 下面我们把宽度设置为200px；<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb5600a8aj30fc04q3yp.jpg" alt=""></p></li><li><p>看div的蓝色边框 ， 宽度就是固定的200px;</p></li><li><p>如果把div设置成行内元素，  它的宽度是怎样的呢,设置属性display:inline<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb5itt1v9j30fu04vdg0.jpg" alt=""></p></li><li><p>div的宽度会收缩</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-元素宽高是由什么决定的&quot;&gt;&lt;a href=&quot;#CSS-元素宽高是由什么决定的&quot; class=&quot;headerlink&quot; title=&quot;CSS-元素宽高是由什么决定的&quot;&gt;&lt;/a&gt;CSS-元素宽高是由什么决定的&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 任何元素
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="行内元素  块级元素  span div" scheme="https://hongtao-huang.github.io/tags/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-span-div/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="https://hongtao-huang.github.io/css-Learn1/"/>
    <id>https://hongtao-huang.github.io/css-Learn1/</id>
    <published>2018-04-10T03:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="引入css的4种方法"><a href="#引入css的4种方法" class="headerlink" title="引入css的4种方法"></a>引入css的4种方法</h2><ol><li>style 属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height:100px;background-color: red;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><div style="height:100px;background-color: red;"></div><ol><li>style 标签<br>在head标签内容中添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line"> div&#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ol><div style="height:100px;background-color: red;"></div><ol><li><p>link 标签引入<br>i 创建一个a.css文件 ，并添加内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line"> height: 100px;</span><br><span class="line"> background-color: red;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> ii 在head中添加 </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;a.css&quot;&gt;</span><br></pre></td></tr></table></figure></li></ol><ol><li>import<br> 该方法是在一个css文件中引入另一个css文件，语法为 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import url(&quot;b.css&quot;)</span><br></pre></td></tr></table></figure></li></ol><pre><code>（以下观点属个人理解）</code></pre><h2 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h2><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    a&#123;</span><br><span class="line">      text-decoration:none;</span><br><span class="line">    &#125;</span><br><span class="line">    ul&#123;</span><br><span class="line">      list-style-type: none;</span><br><span class="line">    &#125;</span><br><span class="line">    ul&gt;li&#123;</span><br><span class="line">      float:left;</span><br><span class="line">      margin:20px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;nav&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;HOME&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;ABOUT&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;CONTACT&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/nav&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/04/09/5acb3337aa951.png" alt="导航栏.png"></p><p>在导航条下面加一个div<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: grey;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="未清除浮动效果"><a href="#未清除浮动效果" class="headerlink" title="未清除浮动效果"></a>未清除浮动效果</h3><p><img src="https://i.loli.net/2018/04/10/5acc1bb8afc89.png" alt="未清楚浮动.png"></p><h3 id="清楚浮动效果"><a href="#清楚浮动效果" class="headerlink" title="清楚浮动效果"></a>清楚浮动效果</h3><p><img src="https://i.loli.net/2018/04/10/5acc207970cc2.png" alt="2018-04-10 10-24-12 的屏幕截图.png"></p><ul><li>所以在给元素添加float后都有可能带来一些问题 ，所以我们需要清除浮动带来的影响。</li><li>清除浮动的办法有很多种，我们只用以下一种方法<br>i 给浮动元素的父元素的类  加  <code>clearfix</code><br>ii <code>clearfix</code> 的css代码具体实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after&#123;</span><br><span class="line">     content:&apos;&apos;;</span><br><span class="line">     display:block;</span><br><span class="line">     clear:both;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="垂直布局"><a href="#垂直布局" class="headerlink" title="垂直布局"></a>垂直布局</h2><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p> 整个网页就是在做一个垂直布局 ， 而水平布局就是在整体的纵向垂直布局上做一块内容的横向水平布局</p><h3 id="各块的垂直布局"><a href="#各块的垂直布局" class="headerlink" title="各块的垂直布局"></a>各块的垂直布局</h3><p><img src="https://i.loli.net/2018/04/10/5acc25c1a9055.png" alt="2018-04-10 10-45-56 的屏幕截图.png"></p><ul><li>可以看到导航栏部分和所有div做整体的垂直布局</li><li>而导航栏这一块里面又做了水平布局</li><li>所以  我觉得浏览器的布局就是整体在做垂直布局，但是又有水平布局组合的复杂布局</li></ul><h2 id="实用且好用的工具推荐"><a href="#实用且好用的工具推荐" class="headerlink" title="实用且好用的工具推荐"></a>实用且好用的工具推荐</h2><p><a href="https://c.m.163.com/news/a/DDJFF6P905118DFD.html?spss=newsapp&amp;fromhistory=1" target="_blank" rel="noopener">工具推荐</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CSS&lt;/h1&gt;&lt;h2 id=&quot;引入css的4种方法&quot;&gt;&lt;a href=&quot;#引入css的4种方法&quot; class=&quot;headerlink&quot; title=&quot;引
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css布局 清除浮动 引入css的方法  推荐工具" scheme="https://hongtao-huang.github.io/tags/css%E5%B8%83%E5%B1%80-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8-%E5%BC%95%E5%85%A5css%E7%9A%84%E6%96%B9%E6%B3%95-%E6%8E%A8%E8%8D%90%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>定时切换全屏多窗口（linux-QT5）</title>
    <link href="https://hongtao-huang.github.io/%E5%AE%9A%E6%97%B6%E5%88%87%E6%8D%A2%E7%AA%97%E5%8F%A3/"/>
    <id>https://hongtao-huang.github.io/定时切换窗口/</id>
    <published>2018-03-26T12:10:00.000Z</published>
    <updated>2018-09-29T13:59:08.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定时切换全屏多窗口（linux-QT5）"><a href="#定时切换全屏多窗口（linux-QT5）" class="headerlink" title="定时切换全屏多窗口（linux-QT5）"></a>定时切换全屏多窗口（linux-QT5）</h1><h2 id="新建多窗口"><a href="#新建多窗口" class="headerlink" title="新建多窗口"></a>新建多窗口</h2><ol><li>新建一个主工程 ，类名为Widget ， 基类为QWidget （主窗口）</li><li>添加新文件， 选择QT ，选择QT设计师界面类，  选择Dialog whitout Buttons （如此随便新建几个，这里我新建了两个  这里是对话窗口 或者  子窗口）</li></ol><h2 id="窗口全屏"><a href="#窗口全屏" class="headerlink" title="窗口全屏"></a>窗口全屏</h2><ol><li>widget 主窗口只需要使用 <code>showFullScreen()</code> 函数</li><li>dialog 对话窗口需要使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dialog2.setWindowFlags(Qt::Window);</span><br><span class="line">dialog2.showFullScreen();</span><br></pre></td></tr></table></figure></li></ol><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dialog2.setWindowFlags(Qt::Dialog);</span><br><span class="line">dialog2.showFullScreen();</span><br></pre></td></tr></table></figure></p><p>这两种方法是将窗口类型升为顶级（主）窗口模式，然后调用<code>dialog2.showFullScreen();</code>函数将子函数全屏显示。</p><ol><li>感兴趣的可以看一下 <a href="https://www.bbsmax.com/A/RnJWY1wYdq/" target="_blank" rel="noopener">关于窗口全屏显示</a></li></ol><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>这里是看的QT 快速入门系列教程第十篇：<br><a href="https://wizardforcel.gitbooks.io/qt-beginning/content/13.html" target="_blank" rel="noopener">QT定时器的两种方式</a></p><h2 id="关于关闭窗口相关函数"><a href="#关于关闭窗口相关函数" class="headerlink" title="关于关闭窗口相关函数"></a>关于关闭窗口相关函数</h2><p><a href="http://blog.csdn.net/xqhrs232/article/details/78211614" target="_blank" rel="noopener">关闭应用程序和窗口的函数</a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="widget-h文件中"><a href="#widget-h文件中" class="headerlink" title="widget.h文件中"></a><code>widget.h</code>文件中</h3><ol><li><p>调用头文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;dialog1.h&quot;</span><br><span class="line">#include &quot;dialog2.h&quot;   //子窗口文件名字的头文件</span><br></pre></td></tr></table></figure></li><li><p><code>private slots:</code> 下添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dialog1Show();</span><br><span class="line">void dialog2Show();</span><br></pre></td></tr></table></figure></li><li><p><code>private:</code> 下添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dialog1 dialog1;</span><br><span class="line">Dialog2 dialog2;</span><br><span class="line">int id1 , num=0; //id1 为定时器溢出变量 ，num 为切换窗口变量</span><br></pre></td></tr></table></figure></li><li><p>添加定时器事件函数声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected:</span><br><span class="line">void timerEvent(QTimerEvent *);</span><br></pre></td></tr></table></figure></li></ol><h3 id="widget-cpp文件中"><a href="#widget-cpp文件中" class="headerlink" title="widget.cpp文件中"></a><code>widget.cpp</code>文件中</h3><ol><li><p>构造函数中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">showFullScreen(); // 为了运行时就可以全屏</span><br><span class="line">id1 = startTimer(5000);  // 开启一个5秒定时器，返回其ID</span><br></pre></td></tr></table></figure></li><li><p>定义定时器事件处理函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Widget::timerEvent(QTimerEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">   if (event-&gt;timerId() == id1) &#123;       // 判断是哪个定时器</span><br><span class="line">       if(num == 0)&#123;        // num=0 的时候调用第一个子窗口显示</span><br><span class="line">            dialog1Show();</span><br><span class="line">       &#125;</span><br><span class="line">       else if(num == 1)&#123;   // num=1 的时候调用第二个子窗口显示</span><br><span class="line">           dialog2Show();</span><br><span class="line">       &#125;</span><br><span class="line">       else if(num == 2)&#123;    //num=2 的时候关闭第二个窗口显示，设置主窗口为全屏显示，然后显示主窗口</span><br><span class="line">           dialog2.close();</span><br><span class="line">           showFullScreen();</span><br><span class="line">           this-&gt;show();</span><br><span class="line">       &#125;</span><br><span class="line">       num++;</span><br><span class="line">       num %= 3;       // 5秒进来一次  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义第一个子窗口显示函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Widget::dialog1Show()&#123;</span><br><span class="line"></span><br><span class="line">    this-&gt;hide();</span><br><span class="line">    dialog1.setWindowFlags(Qt::Dialog);</span><br><span class="line">//    dialog1.setWindowFlags(Qt::Window);</span><br><span class="line">    dialog1.showFullScreen();</span><br><span class="line">    dialog1.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义第二个子窗口显示函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Widget::dialog2Show()&#123;</span><br><span class="line">    dialog1.close();</span><br><span class="line">    dialog2.setWindowFlags(Qt::Dialog);</span><br><span class="line">//    dialog2.setWindowFlags(Qt::Window);</span><br><span class="line">    dialog2.showFullScreen();</span><br><span class="line">    dialog2.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>至此整个全屏定时切换窗口程序就完成了</li></ul><h2 id="简化，合并函数"><a href="#简化，合并函数" class="headerlink" title="简化，合并函数"></a>简化，合并函数</h2><ul><li>这里是把最后这部分显示函数合并为一个函数</li></ul><h3 id="widget-h-中修改"><a href="#widget-h-中修改" class="headerlink" title="widget.h 中修改"></a>widget.h 中修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private slots:</span><br><span class="line">void dialogShow(char cnt);</span><br></pre></td></tr></table></figure><h3 id="widget-cpp中修改"><a href="#widget-cpp中修改" class="headerlink" title="widget.cpp中修改"></a>widget.cpp中修改</h3><ol><li><p>定义 定时器事件处理函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Widget::timerEvent(QTimerEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">   if (event-&gt;timerId() == id1) &#123;       // 判断是哪个定时器</span><br><span class="line">       dialogShow(num);</span><br><span class="line">       num++;</span><br><span class="line">       num %= 3;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义显示函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Widget::dialogShow(char cnt)&#123;</span><br><span class="line">    if(cnt == 0)&#123;</span><br><span class="line">        this-&gt;hide();</span><br><span class="line">        dialog1.setWindowFlags(Qt::Dialog);</span><br><span class="line">    //    dialog1.setWindowFlags(Qt::Window);</span><br><span class="line">        dialog1.showFullScreen();</span><br><span class="line">        dialog1.show();</span><br><span class="line">    &#125;else if(cnt == 1)&#123;</span><br><span class="line">        dialog1.close();</span><br><span class="line">        dialog2.setWindowFlags(Qt::Dialog);</span><br><span class="line">    //    dialog2.setWindowFlags(Qt::Window);</span><br><span class="line">        dialog2.showFullScreen();</span><br><span class="line">        dialog2.show();</span><br><span class="line">    &#125;else if (cnt == 2) &#123;</span><br><span class="line">        dialog2.close();</span><br><span class="line">        showFullScreen();</span><br><span class="line">        this-&gt;show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定时切换全屏多窗口（linux-QT5）&quot;&gt;&lt;a href=&quot;#定时切换全屏多窗口（linux-QT5）&quot; class=&quot;headerlink&quot; title=&quot;定时切换全屏多窗口（linux-QT5）&quot;&gt;&lt;/a&gt;定时切换全屏多窗口（linux-QT5）&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Embedded" scheme="https://hongtao-huang.github.io/categories/Embedded/"/>
    
    
      <category term="定时方式 切换多窗口" scheme="https://hongtao-huang.github.io/tags/%E5%AE%9A%E6%97%B6%E6%96%B9%E5%BC%8F-%E5%88%87%E6%8D%A2%E5%A4%9A%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>linux-QT5-6410-串口</title>
    <link href="https://hongtao-huang.github.io/6410%E4%B8%B2%E5%8F%A3/"/>
    <id>https://hongtao-huang.github.io/6410串口/</id>
    <published>2018-03-19T12:03:50.000Z</published>
    <updated>2018-09-30T01:46:47.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-QT5-6410-串口"><a href="#linux-QT5-6410-串口" class="headerlink" title="linux-QT5-6410-串口"></a>linux-QT5-6410-串口</h1><p>在Linux下我们只能使用查询Polling方式。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><ul><li>新建项目 ，创建dialog，QT桌面项目</li></ul><h2 id="pro文件中添加："><a href="#pro文件中添加：" class="headerlink" title="pro文件中添加："></a>pro文件中添加：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT       += serialport</span><br></pre></td></tr></table></figure><h2 id="dialoh-h中添加"><a href="#dialoh-h中添加" class="headerlink" title="dialoh.h中添加"></a>dialoh.h中添加</h2><h3 id="添加头文件"><a href="#添加头文件" class="headerlink" title="添加头文件"></a>添加头文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtSerialPort/QSerialPort&gt;</span><br><span class="line">#include &lt;QtSerialPort/QSerialPortInfo&gt;   </span><br><span class="line">//以上两个头文件在QT5以下版本需要使用第三方文件，如 qextserialbase.cpp和qextserialbase.h 以及posix_qextserialport.cpp和posix_qextserialport.h</span><br><span class="line">#include &lt;QTimer&gt;</span><br></pre></td></tr></table></figure><h3 id="private下添加"><a href="#private下添加" class="headerlink" title="private下添加"></a>private下添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSerialPort *myCom;</span><br><span class="line">QTimer *readTimer;</span><br></pre></td></tr></table></figure><h3 id="添加私有槽函数"><a href="#添加私有槽函数" class="headerlink" title="添加私有槽函数"></a>添加私有槽函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private slots:</span><br><span class="line">void on_pushButton_clicked(); //”发送数据”按钮槽函数</span><br><span class="line">void readMyCom(); //读取串口</span><br></pre></td></tr></table></figure><h2 id="dialog-cpp中添加"><a href="#dialog-cpp中添加" class="headerlink" title="dialog.cpp中添加"></a>dialog.cpp中添加</h2><h3 id="构造函数下添加"><a href="#构造函数下添加" class="headerlink" title="构造函数下添加"></a>构造函数下添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">myCom = new QSerialPort();  </span><br><span class="line">myCom-&gt;setPortName(&quot;/dev/ttyS0&quot;);  </span><br><span class="line">myCom-&gt;open(QIODevice::ReadWrite);  </span><br><span class="line">myCom-&gt;setBaudRate(QSerialPort::Baud115200);  </span><br><span class="line">myCom-&gt;setBaudRate(QSerialPort::Data8);  </span><br><span class="line">myCom-&gt;setParity(QSerialPort::NoParity);  </span><br><span class="line">myCom-&gt;setStopBits(QSerialPort::OneStop);   </span><br><span class="line">myCom-&gt;setFlowControl(QSerialPort::NoFlowControl);</span><br><span class="line">readTimer = new QTimer(this);</span><br><span class="line">readTimer-&gt;start(100);</span><br><span class="line">connect(readTimer,SIGNAL(timeout()),this,SLOT(readMyCom()));</span><br></pre></td></tr></table></figure><h3 id="构造函数外添加两个私有槽函数的实体"><a href="#构造函数外添加两个私有槽函数的实体" class="headerlink" title="构造函数外添加两个私有槽函数的实体"></a>构造函数外添加两个私有槽函数的实体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Widget::readMyCom() //读取串口数据并显示出来</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray temp = myCom-&gt;readAll(); //读取串口缓冲区的所有数据给临时变量temp</span><br><span class="line">   ui-&gt;textBrowser-&gt;insertPlainText(temp); //将串口的数据显示在窗口的文本浏览器中</span><br><span class="line">&#125;</span><br><span class="line">void Widget::on_pushButton_clicked() //发送数据</span><br><span class="line">&#123;</span><br><span class="line">    myCom-&gt;write(ui-&gt;lineEdit-&gt;text().toAscii()); //以ASCII码形式将数据写入串口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改UI界面"><a href="#修改UI界面" class="headerlink" title="修改UI界面"></a>修改UI界面</h2><ul><li>加入一个textBrowser的文本框</li><li>加入一个 lineEdit的输入框</li><li>加入一个pushbutoon的发送按钮</li></ul><blockquote><p>到这里一个基本的串口工程就建立完成了！！！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux-QT5-6410-串口&quot;&gt;&lt;a href=&quot;#linux-QT5-6410-串口&quot; class=&quot;headerlink&quot; title=&quot;linux-QT5-6410-串口&quot;&gt;&lt;/a&gt;linux-QT5-6410-串口&lt;/h1&gt;&lt;p&gt;在Linux下我们只
      
    
    </summary>
    
      <category term="Embedded" scheme="https://hongtao-huang.github.io/categories/Embedded/"/>
    
    
      <category term="串口" scheme="https://hongtao-huang.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>HTML语义化</title>
    <link href="https://hongtao-huang.github.io/html-%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
    <id>https://hongtao-huang.github.io/html-语义化/</id>
    <published>2018-03-18T07:20:00.000Z</published>
    <updated>2018-09-29T13:59:08.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-语义化-iframe-a-form的使用"><a href="#HTML-语义化-iframe-a-form的使用" class="headerlink" title="HTML-语义化-(iframe-a-form的使用)"></a>HTML-语义化-(iframe-a-form的使用)</h1><h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><p>参考资料：<br><a href="http://justineo.github.io/slideshows/semantic-html/" target="_blank" rel="noopener">semantic-html</a><br><a href="http://www.oschina.net/translate/about-html-semantics-front-end-architecture" target="_blank" rel="noopener">关于语义化 HTML 以及前端架构的一点思考</a><br><a href="http://www.zhihu.com/question/20455165" target="_blank" rel="noopener">如何理解 web 语义化</a></p><blockquote><p>语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p></blockquote><p>列举几个常见的标签：<br>标题从大到小： h1 , h2 , h3 , h4 , h5 , h6<br>超链接： a<br>段落： p<br>无序列表： ul&gt;li<br>有序列表： ol&gt;li<br>自定义列表： dl&gt;{dt , dd}<br><a href="http://www.runoob.com/tags/tag-header.html" target="_blank" rel="noopener"><code>&lt;header&gt;</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/main" target="_blank" rel="noopener"><code>&lt;main&gt;</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section" target="_blank" rel="noopener"><code>&lt;section&gt;</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/footer" target="_blank" rel="noopener"><code>&lt;footer&gt;</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article" target="_blank" rel="noopener"><code>&lt;article&gt;</code></a></p><h2 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>跳转页面。 发起 HTTP GET 请求</p><h3 id="target-属性"><a href="#target-属性" class="headerlink" title="target 属性"></a>target 属性</h3><ul><li>_blank 在新页面打开网页</li><li>_self 在当前页面打开网页  </li><li>_parent 在父页面打开网页  ， 这种要在当前页面被嵌套在一个iframe网页中容易体现出来</li><li>_top 在最外围页面打开网页 ， 这种要在当前页面被嵌套在多个iframe网页中容易体现出来</li></ul><h3 id="download"><a href="#download" class="headerlink" title="download"></a>download</h3><ul><li>表示下载href所对应的网页</li></ul><h2 id="iframe标签"><a href="#iframe标签" class="headerlink" title="iframe标签"></a>iframe标签</h2><p>默认宽高为300 * 150大小</p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul><li>可以在一个网页嵌套一个网页<br>例如：<br><img src="http://ww1.sinaimg.cn/large/006WOZytgy1fpg8heal7qj309508sdfv.jpg" alt=""></li></ul><h3 id="与-a标签"><a href="#与-a标签" class="headerlink" title="与 a标签"></a>与 a标签</h3><p>看图：<br><img src="http://ww1.sinaimg.cn/large/006WOZytgy1fpgqn7mfjuj309i084gm1.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe name=xxx src=&quot;http://baidu.com&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;a href=&quot;http://qq.com&quot; target=&quot;xxx&quot;&gt;QQ&lt;/a&gt;</span><br><span class="line">    &lt;p&gt;我是iframe外面的P标签&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>QQ为 a 标签链接  ，它的target 属性等于 <code>xxx</code>,点击QQ 就会在iframe 中打开<code>qq.com</code>的网页<br>iframe 标签中本来打开的网页时<code>baidu.com</code> ，iframe 有一个属性时<code>name</code> ，<code>name</code>属性等于 a标签的target属性的值，所以点击a标签的时候就会在iframe中打开a标签中的URL。</p><h2 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h2><p>跳转页面。 发起 HTTP POST 请求<br>常用属性</p><ul><li>action ：  规定当提交表单时向何处发送表单数据。值为：URL</li><li>method ：  规定用于发送表单数据的 HTTP 方法。值只能是： GET 或 POST请求</li><li>target ：  规定在何处打开 action URL。值为：<br>i. _blank<br>ii. _self<br>iii. _parent<br>iv. _top<br>和 标签是一样的。  </li><li><code>&lt;form&gt;</code> 元素包含一个或多个如下的表单元素：   <code>&lt;input&gt;&lt;textarea&gt;&lt;button&gt;&lt;select&gt;&lt;option&gt;&lt;optgroup&gt;&lt;fieldset&gt;&lt;label&gt;</code>  </li></ul><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>type属性:</p><ol><li>text： 简单文本输入</li><li>password： 加密文本输入</li><li>radio： 单选框 ，相同的name ，为一组单选框</li><li>chekbox： 复选框 ， 相同的name ，为一组复选框</li><li>reset： 重置按钮 ，value为按钮名字，重置之前所有的输入</li><li>submit：提交按钮 ，value为按钮名字 ，将输入的内容提交至 form 标签的 action属性对应的URL中</li><li>button： 普通按钮 ，value为按钮名字<ul><li>注意： 要想输入的内容能提交 ， 需要加一个name属性</li></ul></li></ol><p>require属性： 加了这个属性就表示，输入框中必须有输入</p><p>lable : lable for id , lable标签for 中值  ，对应lable想关联的标签的id 值。</p><p>textarea: 文本输入框</p><p>select ： 下拉菜单 ， option为选项</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML-语义化-iframe-a-form的使用&quot;&gt;&lt;a href=&quot;#HTML-语义化-iframe-a-form的使用&quot; class=&quot;headerlink&quot; title=&quot;HTML-语义化-(iframe-a-form的使用)&quot;&gt;&lt;/a&gt;HTML-语义化-
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="W3C MDN HTML Tag 空Tag 可替换Tag" scheme="https://hongtao-huang.github.io/tags/W3C-MDN-HTML-Tag-%E7%A9%BATag-%E5%8F%AF%E6%9B%BF%E6%8D%A2Tag/"/>
    
  </entry>
  
</feed>
